import EmbedCallback from './lib/callback';
import type { EmbedEventName, EmbedParameters, ScoreTrackConfiguration, PartConfiguration, NoteCursorPosition, NoteCursorPositionOptional, MeasureDetails, NoteDetails, MetronomeMode, PlaybackPosition } from './types';
declare class Embed {
    origin: string;
    element: HTMLIFrameElement;
    embedCallback: EmbedCallback;
    /**
     * Create a new Flat Embed
     *
     * @param element A reference to a Flat Embed iframe or a container for the new iframe
     * @param parameters Parameters for the new iframe
     */
    constructor(element: HTMLIFrameElement | HTMLElement | string, parameters?: EmbedParameters);
    ready(): any;
    /**
     * Call a method on the embed
     *
     * @param method Name of the method to call
     * @param parameters Method parameters
     * @returns Call result from Embed (if any)
     */
    call(method: string, parameters?: Record<string, unknown> | string | string[] | number | boolean | Uint8Array): Promise<unknown>;
    /**
     * Subscribe to a specific event
     *
     * @param event The name of the event.
     * @param callback The function to call when receiving an event
     */
    on(event: EmbedEventName, callback: () => void): void;
    /**
     * Unsubscribe to a specific event
     *
     * @param event The name of the event.
     * @param callback The function to unsubscribe
     */
    off(event: EmbedEventName, callback?: () => void): void;
    /**
     * Load a score hosted on Flat
     *
     * @param score The unique identifier of the score or an object with { score, sharingKey }
     * @return {Promise}
     * @reject {ApiError} Unable to load the score
     */
    loadFlatScore(score: string | {
        score: string;
        sharingKey?: string;
    }): Promise<void>;
    /**
     * Load a MusicXML score
     *
     * @param score The MusicXML file
     * @return {Promise}
     * @reject {Error} Unable to load the score
     */
    loadMusicXML(score: string | Uint8Array): Promise<void>;
    /**
     * Load a Flat JSON score
     *
     * @param score The JSON of the score
     * @return {Promise}
     * @reject {Error} Unable to load the score
     */
    loadJSON(score: string | Record<string, unknown>): Promise<void>;
    /**
     * Get the score in Flat JSON format
     *
     * @return The Flat data format
     */
    getJSON(): Promise<Record<string, unknown>>;
    /**
     * Convert the displayed score in MusicXML
     *
     * @param options Conversion options (`compressed`)
     * @return {Promise}
     * @fullfill MusicXML File
     * @reject Conversion error
     */
    getMusicXML(options?: {
        compressed?: boolean;
    }): Promise<string | Uint8Array>;
    /**
     * Convert the displayed score in PNG
     *
     * @return {Promise}
     * @fullfill PNG File (Uint8Array or string for dataURL)
     * @reject Conversion error
     */
    getPNG(options?: {
        /** Export result (either a PNG returned as Uint8Array or in dataURL) */
        result?: 'Uint8Array' | 'dataURL';
        /** DPI of exported image (min: 50, max: 300, default: 150) */
        dpi?: number;
        /** Layout of exported image */
        layout?: 'track' | 'page';
    }): Promise<Uint8Array | string>;
    /**
     * Convert the displayed score in MIDI
     *
     * @return {Promise}
     * @fullfill MIDI File
     * @reject Conversion error
     */
    getMIDI(): Promise<Uint8Array>;
    /**
     * Get the metadata of the score (for scores hosted on Flat)
     *
     * TODO: Type the result from OpenAPI response
     *
     * @return {Promise}
     * @fulfill {object} The Flat data format (result from https://flat.io/developers/api/reference/#operation/getScore)
     */
    getFlatScoreMetadata(): Promise<unknown>;
    /**
     * Get the whole embed config
     *
     * TODO: Type all embed options
     *
     * @return {Promise}
     * @fullfill {object} An object containing the config of the embed
     */
    getEmbedConfig(): Promise<Record<string, unknown>>;
    /**
     * Set a config for the embed mode
     * This config can be fetched with `getEmbed()` (as `editor` value)
     * This config will be applied at the next score loading
     *
     * TODO: Type all options
     *
     * @param {object} editor The editor config
     * @return {Promise}
     * @fullfill {object} An object containing the config of the editor
     */
    setEditorConfig(editor: Record<string, unknown>): Promise<void>;
    /**
     * Toggle fullscreen state
     *
     * @param {boolean} active `true` to switch on fullscreen, `false` to switch off
     * @return {Promise} Once the state changed
     */
    fullscreen(active: boolean): Promise<void>;
    /**
     * Start the playback
     */
    play(): Promise<void>;
    /**
     * Pause the playback
     */
    pause(): Promise<void>;
    /**
     * Stop the playback
     */
    stop(): Promise<void>;
    /**
     * Mute playback
     */
    mute(): Promise<void>;
    /**
     * Get the current master volume
     */
    getMasterVolume(): Promise<number>;
    /**
     * Set the current master volume
     */
    setMasterVolume(parameters: {
        volume: number;
    }): Promise<void>;
    /**
     * Get the volume of a part
     */
    getPartVolume(parameters: {
        partUuid: string;
    }): Promise<number>;
    /**
     * Set the volume of a part
     */
    setPartVolume(parameters: {
        partUuid: string;
        volume: number;
    }): Promise<void>;
    /**
     * Mute a part
     */
    mutePart(parameters: {
        partUuid: string;
    }): Promise<void>;
    /**
     * Mute a part
     */
    unmutePart(parameters: {
        partUuid: string;
    }): Promise<void>;
    /**
     * Enable the solo mode for a part
     */
    setPartSoloMode(parameters: {
        partUuid: string;
    }): Promise<void>;
    /**
     * Disable the solo mode for a part
     */
    unsetPartSoloMode(parameters: {
        partUuid: string;
    }): Promise<void>;
    /**
     * Get the state of the solo mode of a part
     */
    getPartSoloMode(parameters: {
        partUuid: string;
    }): Promise<boolean>;
    /**
     * Get the volume of a part
     */
    getPartReverb(parameters: {
        partUuid: string;
    }): Promise<number>;
    /**
     * Set the volume of a part
     */
    setPartReverb(parameters: {
        partUuid: string;
        reverberation: number;
    }): Promise<void>;
    /**
     * Configure a new audio or video track
     */
    setTrack(parameters: ScoreTrackConfiguration): Promise<void>;
    /**
     * Enabled a previously configured track
     */
    useTrack(parameters: {
        id: string;
    }): Promise<void>;
    /**
     * Seek the audio track to a specified duration
     */
    seekTrackTo(parameters: {
        time: number;
    }): Promise<void>;
    /**
     * Print the score
     */
    print(): Promise<void>;
    /**
     * Get the current zoom ratio
     *
     * @return {Promise}
     * @fullfill {number} The current scale ratio (0.5 to 3)
     */
    getZoom(): Promise<number>;
    /**
     * Set a new zoom ratio (this will disable the zoom auto if set)
     *
     * @param {number} zoom The scale ratio (0.5 to 3)
     * @return {Promise}
     * @fullfill {number} The scale ratio applied
     */
    setZoom(zoom: number): Promise<number>;
    /**
     * Get the auto-zoom
     *
     * @return {Promise}
     * @fullfill {boolean} `true` if enabled, `false` if disabled
     */
    getAutoZoom(): Promise<boolean>;
    /**
     * Enable or disable the auto-zoom
     *
     * @param {boolean} state `true` if enabled, `false` if disabled
     * @return {Promise}
     * @fullfill {boolean} The auto-zoom mode
     */
    setAutoZoom(state: boolean): Promise<boolean>;
    /**
     * Set the focus to the score
     */
    focusScore(): Promise<void>;
    /**
     * Get cursor position
     *
     * @return {Promise}
     * @fullfill {boolean} Current cursor position
     */
    getCursorPosition(): Promise<NoteCursorPosition>;
    /**
     * Set cursor position
     *
     * @param {object} position New cursor position
     * @return {Promise}
     * @fullfill {boolean} Current cursor position
     */
    setCursorPosition(position: NoteCursorPositionOptional): Promise<void>;
    /**
     * Get all the parts information
     *
     * @return {Promise}
     * @fullfill {array} List of the parts
     */
    getParts(): Promise<PartConfiguration[]>;
    /**
     * Get the displayed parts
     *
     * @return {Promise}
     * @fullfill {array} List of the displayed parts
     */
    getDisplayedParts(): Promise<PartConfiguration[]>;
    /**
     * Choose the parts to display
     *
     * @param {array} parts List of the parts to display (UUIDs, indexes/idx, names or abbv)
     * @return {Promise}
     */
    setDisplayedParts(parts: string[]): Promise<void>;
    /**
     * Get the number of measures in the score.
     *
     * @return {Promise}
     * @fullfill {Number} The number of measures in the score
     */
    getNbMeasures(): Promise<number>;
    /**
     * Get the measures uuids of the score
     *
     * @return {Promise}
     * @fullfill {Array} The list of measures uuids.
     */
    getMeasuresUuids(): Promise<string[]>;
    /**
     * Get all the parts information
     *
     * @return {Promise}
     * @fullfill {object} Measure details
     */
    getMeasureDetails(): Promise<MeasureDetails>;
    /**
     * Get the number of parts in the score.
     *
     * @return {Promise}
     * @fullfill {Number} The number of parts in the score
     */
    getNbParts(): Promise<number>;
    /**
     * Get the parts uuids of the score
     *
     * @return {Promise}
     * @fullfill {Array} The list of parts uuids.
     */
    getPartsUuids(): Promise<string[]>;
    /**
     * Get the voice uuids that are present in a given measure.
     *
     * @return {Promise}
     * @fullfill {Array} The list of voices uuids.
     */
    getMeasureVoicesUuids(parameters: {
        partUuid: string;
        measureUuid: string;
    }): Promise<string[]>;
    /**
     * Get the number of notes in a voice for a given measure.
     *
     * @return {Promise}
     * @fullfill {Number} The number of notes in a voice for a given measure.
     */
    getMeasureNbNotes(parameters: {
        partUuid: string;
        measureUuid: string;
        voiceUuid: string;
    }): Promise<number>;
    /**
     * Get information about a specific note.
     *
     * @return {Promise}
     * @fullfill {object} Note details
     */
    getNoteData(parameters: {
        partUuid: string;
        measureUuid: string;
        voiceUuid: string;
        noteIdx: number;
    }): Promise<NoteDetails>;
    /**
     * Get information about a specific note.
     *
     * @return {Promise}
     * @fullfill {Number} Note index in the voice/measure.
     */
    playbackPositionToNoteIdx(parameters: {
        partUuid: string;
        voiceUuid: string;
        playbackPosition: PlaybackPosition;
    }): Promise<number>;
    /**
     * Get all the parts information
     *
     * @return {Promise}
     * @fullfill {object} Note details
     */
    getNoteDetails(): Promise<NoteDetails>;
    /**
     * Move the cursor to the next left item in the score (grace note, note or rest).
     *
     * @param mute false to play the note the cursor is moving to
     */
    goLeft(mute?: boolean): Promise<void>;
    /**
     * Move the cursor to the next right item in the score (grace note, note or rest).
     *
     * @param mute false to play the note the cursor is moving to
     */
    goRight(mute?: boolean): Promise<void>;
    /**
     * Get the current metronome mode
     *
     * @returns {Promise}
     * @fullfill {Number} The metronome mode
     */
    getMetronomeMode(): Promise<MetronomeMode>;
    /**
     * Sett the metronome mode.
     *
     * Mode is defined as:
     * ``` javascript
     * const METRONOME_MODES = {
     *   COUNT_IN: 0,
     *   CONTINUOUS: 1,
     *   DISABLED: 2,
     * };
     * ```
     *
     * @param {Number} mode the new metronome mode
     * @return {Promise}
     */
    setMetronomeMode(mode: MetronomeMode): Promise<void>;
    /**
     * Get the current metronome mode
     *
     * @returns {Promise}
     * @fullfill The Playback speed
     */
    getPlaybackSpeed(): Promise<number>;
    /**
     * Set the playback speed.
     *
     * 1 is the regular value, then it is a value between 0.2 and 2.
     *
     * @param {Number} speed the new playback speed
     */
    setPlaybackSpeed(speed: number): Promise<void>;
    /**
     * Scroll to the cursor position in the score.
     *
     * The scrolling is done asynchronously, so it is not guaranteed that it will be complete
     * by the time the callback is called.
     */
    scrollToCursor(): Promise<void>;
}
export default Embed;
