var g = Object.defineProperty;
var d = (r, e, t) => e in r ? g(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var n = (r, e, t) => (d(r, typeof e != "symbol" ? e + "" : e, t), t);
if (typeof window.postMessage == "undefined")
  throw new Error("The Flat Embed JS API is not supported in this browser");
function f(r) {
  if (typeof r == "string") {
    const e = document.getElementById(r);
    if (!e)
      throw new TypeError(`The DOM element with the identifier "${r}" was not found.`);
    r = e;
  }
  if (!(r instanceof window.HTMLElement))
    throw new TypeError("The first parameter must be an existing DOM element or an identifier.");
  if (r.nodeName !== "IFRAME") {
    const e = r.querySelector("iframe");
    e && (r = e);
  }
  return r;
}
function b(r) {
  let e = r.baseUrl || "https://flat-embed.com";
  e += "/" + (r.score || "blank");
  const t = Object.assign(
    {
      jsapi: !0
    },
    r.embedParams
  ), s = Object.keys(t).map((i) => `${encodeURIComponent(i)}=${encodeURIComponent(t[i])}`).join("&");
  return e + "?" + s;
}
function m(r, e) {
  const t = b(e), s = document.createElement("iframe");
  return s.setAttribute("src", t), s.setAttribute("width", e.width || "100%"), s.setAttribute("height", e.height || "100%"), s.setAttribute("allowfullscreen", "true"), s.setAttribute("allow", "autoplay; midi"), s.setAttribute("frameborder", "0"), e.lazy && s.setAttribute("loading", "lazy"), r.appendChild(s), s;
}
function u(r, e, t) {
  if (!r.element.contentWindow || !r.element.contentWindow.postMessage)
    throw new Error("No `contentWindow` or `contentWindow.postMessage` available on the element");
  const s = {
    method: e,
    parameters: t
  };
  r.element.contentWindow.postMessage(s, r.origin);
}
function p(r) {
  return typeof r == "string" && (r = JSON.parse(r)), r;
}
class M {
  constructor(e) {
    n(this, "embed");
    n(this, "promises");
    n(this, "eventCallbacks");
    return this.embed = e, this.promises = {}, this.eventCallbacks = {}, this;
  }
  pushCall(e, t, s) {
    this.promises[e] = this.promises[e] || [], this.promises[e].push({ resolve: t, reject: s });
  }
  /**
   * Register a callback for a specified event
   *
   * @param event The name of the event.
   * @param callback The function to call when receiving an event
   * @return `true` if it is the first subscriber, `false otherwise`
   */
  subscribeEvent(e, t) {
    return this.eventCallbacks[e] = this.eventCallbacks[e] || [], this.eventCallbacks[e].push(t), this.eventCallbacks[e].length === 1;
  }
  /**
   * Unregister a callback for a specified event
   *
   * @param event The name of the event.
   * @param callback The function to call when receiving an event
   * @return `true` if it is the last subscriber, `false otherwise`
   */
  unsubscribeEvent(e, t) {
    if (!this.eventCallbacks[e])
      return !1;
    if (t) {
      const s = this.eventCallbacks[e].indexOf(t);
      s >= 0 && this.eventCallbacks[e].splice(s, 1);
    } else
      this.eventCallbacks[e] = [];
    return !t || this.eventCallbacks[e].length === 0;
  }
  /**
   * Process a message received from postMessage
   *
   * @param {object} data The data received from postMessage
   */
  process(e) {
    "method" in e && e.method ? this.processMethodResponse(e) : "event" in e && e.event && this.processEvent(e);
  }
  /**
   * Process a method response
   *
   * @param {object} data The data received from postMessage
   */
  processMethodResponse(e) {
    if (!this.promises[e.method])
      return;
    const t = this.promises[e.method].shift();
    t && (e.error ? t.reject(e.error) : t.resolve(e.response));
  }
  /**
   * Process a receieved event
   *
   * @param {object} data The data received from postMessage
   */
  processEvent(e) {
    !this.eventCallbacks[e.event] || this.eventCallbacks[e.event].length === 0 || this.eventCallbacks[e.event].forEach((t) => {
      t.call(this.embed, e.parameters);
    });
  }
}
const a = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
class w {
  /**
   * Create a new Flat Embed
   *
   * @param element A reference to a Flat Embed iframe or a container for the new iframe
   * @param parameters Parameters for the new iframe
   */
  constructor(e, t = {}) {
    n(this, "origin", "*");
    n(this, "element");
    n(this, "embedCallback");
    if (e = f(e), a.has(e))
      return a.get(e);
    e.nodeName !== "IFRAME" && (e = m(e, t)), this.element = e, this.embedCallback = new M(this);
    const s = new Promise((i) => {
      const h = (o) => {
        if (this.element.contentWindow !== o.source)
          return;
        this.origin === "*" && (this.origin = o.origin);
        const l = p(o.data);
        if (l.event === "ready" || l.method === "ping") {
          i();
          return;
        }
        this.embedCallback.process(l);
      };
      window.addEventListener("message", h, !1), u(this, "ping");
    });
    return a.set(this.element, this), c.set(this.element, s), this;
  }
  ready() {
    return c.get(this.element);
  }
  /**
   * Call a method on the embed
   *
   * @param method Name of the method to call
   * @param parameters Method parameters
   * @returns Call result from Embed (if any)
   */
  call(e, t = {}) {
    return new Promise((s, i) => this.ready().then(() => {
      this.embedCallback.pushCall(e, s, i), u(this, e, t);
    }));
  }
  /**
   * Subscribe to a specific event
   *
   * @param event The name of the event.
   * @param callback The function to call when receiving an event
   */
  on(e, t) {
    if (typeof e != "string")
      throw new TypeError("An event name (string) is required");
    if (typeof t != "function")
      throw new TypeError("An callback (function) is required");
    this.embedCallback.subscribeEvent(e, t) && this.call("addEventListener", e).catch(() => {
    });
  }
  /**
   * Unsubscribe to a specific event
   *
   * @param event The name of the event.
   * @param callback The function to unsubscribe
   */
  off(e, t) {
    if (typeof e != "string")
      throw new TypeError("An event name (string) is required");
    this.embedCallback.unsubscribeEvent(e, t) && this.call("removeEventListener", e).catch(() => {
    });
  }
  /**
   * Load a score hosted on Flat
   *
   * @param score The unique identifier of the score or an object with { score, sharingKey }
   * @return {Promise}
   * @reject {ApiError} Unable to load the score
   */
  loadFlatScore(e) {
    return typeof e == "string" && (e = { score: e }), this.call("loadFlatScore", e);
  }
  /**
   * Load a MusicXML score
   *
   * @param score The MusicXML file
   * @return {Promise}
   * @reject {Error} Unable to load the score
   */
  loadMusicXML(e) {
    return this.call("loadMusicXML", e);
  }
  /**
   * Load a Flat JSON score
   *
   * @param score The JSON of the score
   * @return {Promise}
   * @reject {Error} Unable to load the score
   */
  loadJSON(e) {
    return this.call("loadJSON", e);
  }
  /**
   * Get the score in Flat JSON format
   *
   * @return The Flat data format
   */
  getJSON() {
    return this.call("getJSON");
  }
  /**
   * Convert the displayed score in MusicXML
   *
   * @param options Conversion options (`compressed`)
   * @return {Promise}
   * @fullfill MusicXML File
   * @reject Conversion error
   */
  getMusicXML(e) {
    return new Promise((t, s) => {
      if (e = e || {}, typeof e != "object")
        return s(new TypeError("Options must be an object"));
      this.call("getMusicXML", e).then((i) => t(typeof i == "string" ? i : new Uint8Array(i))).catch(s);
    });
  }
  /**
   * Convert the displayed score in PNG
   *
   * @return {Promise}
   * @fullfill PNG File (Uint8Array or string for dataURL)
   * @reject Conversion error
   */
  getPNG(e) {
    return new Promise((t, s) => {
      if (e = e || {}, typeof e != "object")
        return s(new TypeError("Options must be an object"));
      this.call("getPNG", e).then((i) => {
        if (typeof i == "string")
          return t(i);
        t(new Uint8Array(i));
      }).catch(s);
    });
  }
  /**
   * Convert the displayed score in MIDI
   *
   * @return {Promise}
   * @fullfill MIDI File
   * @reject Conversion error
   */
  getMIDI() {
    return this.call("getMIDI").then((e) => new Uint8Array(e));
  }
  /**
   * Get the metadata of the score (for scores hosted on Flat)
   *
   * TODO: Type the result from OpenAPI response
   *
   * @return {Promise}
   * @fulfill {object} The Flat data format (result from https://flat.io/developers/api/reference/#operation/getScore)
   */
  getFlatScoreMetadata() {
    return this.call("getFlatScoreMetadata");
  }
  /**
   * Get the whole embed config
   *
   * TODO: Type all embed options
   *
   * @return {Promise}
   * @fullfill {object} An object containing the config of the embed
   */
  getEmbedConfig() {
    return this.call("getEmbedConfig");
  }
  /**
   * Set a config for the embed mode
   * This config can be fetched with `getEmbed()` (as `editor` value)
   * This config will be applied at the next score loading
   *
   * TODO: Type all options
   *
   * @param {object} editor The editor config
   * @return {Promise}
   * @fullfill {object} An object containing the config of the editor
   */
  setEditorConfig(e) {
    return this.call("setEditorConfig", e);
  }
  /**
   * Toggle fullscreen state
   *
   * @param {boolean} active `true` to switch on fullscreen, `false` to switch off
   * @return {Promise} Once the state changed
   */
  fullscreen(e) {
    return this.call("fullscreen", e);
  }
  /**
   * Start the playback
   */
  play() {
    return this.call("play");
  }
  /**
   * Pause the playback
   */
  pause() {
    return this.call("pause");
  }
  /**
   * Stop the playback
   */
  stop() {
    return this.call("stop");
  }
  /**
   * Mute playback
   */
  mute() {
    return this.call("mute");
  }
  /**
   * Get the current master volume
   */
  getMasterVolume() {
    return this.call("getMasterVolume");
  }
  /**
   * Set the current master volume
   */
  setMasterVolume(e) {
    return this.call("setMasterVolume", e);
  }
  /**
   * Get the volume of a part
   */
  getPartVolume(e) {
    return this.call("getPartVolume", e);
  }
  /**
   * Set the volume of a part
   */
  setPartVolume(e) {
    return this.call("setPartVolume", e);
  }
  /**
   * Mute a part
   */
  mutePart(e) {
    return this.call("mutePart", e);
  }
  /**
   * Mute a part
   */
  unmutePart(e) {
    return this.call("unmutePart", e);
  }
  /**
   * Enable the solo mode for a part
   */
  setPartSoloMode(e) {
    return this.call("setPartSoloMode", e);
  }
  /**
   * Disable the solo mode for a part
   */
  unsetPartSoloMode(e) {
    return this.call("unsetPartSoloMode", e);
  }
  /**
   * Get the state of the solo mode of a part
   */
  getPartSoloMode(e) {
    return this.call("getPartSoloMode", e);
  }
  /**
   * Get the volume of a part
   */
  getPartReverb(e) {
    return this.call("getPartReverb", e);
  }
  /**
   * Set the volume of a part
   */
  setPartReverb(e) {
    return this.call("setPartReverb", e);
  }
  /**
   * Configure a new audio or video track
   */
  setTrack(e) {
    return this.call("setTrack", e);
  }
  /**
   * Enabled a previously configured track
   */
  useTrack(e) {
    return this.call("useTrack", e);
  }
  /**
   * Seek the audio track to a specified duration
   */
  seekTrackTo(e) {
    return this.call("seekTrackTo", e);
  }
  /**
   * Print the score
   */
  print() {
    return this.call("print");
  }
  /**
   * Get the current zoom ratio
   *
   * @return {Promise}
   * @fullfill {number} The current scale ratio (0.5 to 3)
   */
  getZoom() {
    return this.call("getZoom");
  }
  /**
   * Set a new zoom ratio (this will disable the zoom auto if set)
   *
   * @param {number} zoom The scale ratio (0.5 to 3)
   * @return {Promise}
   * @fullfill {number} The scale ratio applied
   */
  setZoom(e) {
    return this.call("setZoom", e);
  }
  /**
   * Get the auto-zoom
   *
   * @return {Promise}
   * @fullfill {boolean} `true` if enabled, `false` if disabled
   */
  getAutoZoom() {
    return this.call("getAutoZoom");
  }
  /**
   * Enable or disable the auto-zoom
   *
   * @param {boolean} state `true` if enabled, `false` if disabled
   * @return {Promise}
   * @fullfill {boolean} The auto-zoom mode
   */
  setAutoZoom(e) {
    return this.call("setAutoZoom", e);
  }
  /**
   * Set the focus to the score
   */
  focusScore() {
    return this.call("focusScore");
  }
  /**
   * Get cursor position
   *
   * @return {Promise}
   * @fullfill {boolean} Current cursor position
   */
  getCursorPosition() {
    return this.call("getCursorPosition");
  }
  /**
   * Set cursor position
   *
   * @param {object} position New cursor position
   * @return {Promise}
   * @fullfill {boolean} Current cursor position
   */
  setCursorPosition(e) {
    return this.call("setCursorPosition", e);
  }
  /**
   * Get all the parts information
   *
   * @return {Promise}
   * @fullfill {array} List of the parts
   */
  getParts() {
    return this.call("getParts");
  }
  /**
   * Get the displayed parts
   *
   * @return {Promise}
   * @fullfill {array} List of the displayed parts
   */
  getDisplayedParts() {
    return this.call("getDisplayedParts");
  }
  /**
   * Choose the parts to display
   *
   * @param {array} parts List of the parts to display (UUIDs, indexes/idx, names or abbv)
   * @return {Promise}
   */
  setDisplayedParts(e) {
    return this.call("setDisplayedParts", e);
  }
  /**
   * Get the number of measures in the score.
   *
   * @return {Promise}
   * @fullfill {Number} The number of measures in the score
   */
  getNbMeasures() {
    return this.call("getNbMeasures");
  }
  /**
   * Get the measures uuids of the score
   *
   * @return {Promise}
   * @fullfill {Array} The list of measures uuids.
   */
  getMeasuresUuids() {
    return this.call("getMeasuresUuids");
  }
  /**
   * Get all the parts information
   *
   * @return {Promise}
   * @fullfill {object} Measure details
   */
  getMeasureDetails() {
    return this.call("getMeasureDetails");
  }
  /**
   * Get the number of parts in the score.
   *
   * @return {Promise}
   * @fullfill {Number} The number of parts in the score
   */
  getNbParts() {
    return this.call("getNbParts");
  }
  /**
   * Get the parts uuids of the score
   *
   * @return {Promise}
   * @fullfill {Array} The list of parts uuids.
   */
  getPartsUuids() {
    return this.call("getPartsUuids");
  }
  /**
   * Get the voice uuids that are present in a given measure.
   *
   * @return {Promise}
   * @fullfill {Array} The list of voices uuids.
   */
  getMeasureVoicesUuids(e) {
    return this.call("getMeasureVoicesUuids", e);
  }
  /**
   * Get the number of notes in a voice for a given measure.
   *
   * @return {Promise}
   * @fullfill {Number} The number of notes in a voice for a given measure.
   */
  getMeasureNbNotes(e) {
    return this.call("getMeasureNbNotes", e);
  }
  /**
   * Get information about a specific note.
   *
   * @return {Promise}
   * @fullfill {object} Note details
   */
  getNoteData(e) {
    return this.call("getNoteData", e);
  }
  /**
   * Get information about a specific note.
   *
   * @return {Promise}
   * @fullfill {Number} Note index in the voice/measure.
   */
  playbackPositionToNoteIdx(e) {
    return this.call("playbackPositionToNoteIdx", e);
  }
  /**
   * Get all the parts information
   *
   * @return {Promise}
   * @fullfill {object} Note details
   */
  getNoteDetails() {
    return this.call("getNoteDetails");
  }
  /**
   * Move the cursor to the next left item in the score (grace note, note or rest).
   *
   * @param mute false to play the note the cursor is moving to
   */
  goLeft(e = !1) {
    return this.call("goLeft", { mute: e });
  }
  /**
   * Move the cursor to the next right item in the score (grace note, note or rest).
   *
   * @param mute false to play the note the cursor is moving to
   */
  goRight(e = !1) {
    return this.call("goRight", { mute: e });
  }
  /**
   * Get the current metronome mode
   *
   * @returns {Promise}
   * @fullfill {Number} The metronome mode
   */
  getMetronomeMode() {
    return this.call("getMetronomeMode");
  }
  /**
   * Sett the metronome mode.
   *
   * Mode is defined as:
   * ``` javascript
   * const METRONOME_MODES = {
   *   COUNT_IN: 0,
   *   CONTINUOUS: 1,
   *   DISABLED: 2,
   * };
   * ```
   *
   * @param {Number} mode the new metronome mode
   * @return {Promise}
   */
  setMetronomeMode(e) {
    return this.call("setMetronomeMode", { mode: e });
  }
  /**
   * Get the current metronome mode
   *
   * @returns {Promise}
   * @fullfill The Playback speed
   */
  getPlaybackSpeed() {
    return this.call("getPlaybackSpeed");
  }
  /**
   * Set the playback speed.
   *
   * 1 is the regular value, then it is a value between 0.2 and 2.
   *
   * @param {Number} speed the new playback speed
   */
  setPlaybackSpeed(e) {
    return this.call("setPlaybackSpeed", { speed: e });
  }
  /**
   * Scroll to the cursor position in the score.
   *
   * The scrolling is done asynchronously, so it is not guaranteed that it will be complete
   * by the time the callback is called.
   */
  scrollToCursor() {
    return this.call("scrollToCursor");
  }
}
export {
  w as default
};
//# sourceMappingURL=flat-embed.mjs.map
