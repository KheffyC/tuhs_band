{"version":3,"file":"flat-embed.mjs","sources":["../src/lib/compatibility.ts","../src/lib/dom.ts","../src/lib/embed.ts","../src/lib/communication.ts","../src/lib/callback.ts","../src/embed.ts"],"sourcesContent":["if (typeof window.postMessage === 'undefined') {\n  throw new Error('The Flat Embed JS API is not supported in this browser');\n}\n","/**\n * Select and normalize the DOM element input\n */\nexport function normalizeElement(\n  element: HTMLIFrameElement | HTMLElement | string,\n): HTMLIFrameElement | HTMLElement {\n  // Find an element by identifier\n  if (typeof element === 'string') {\n    const container = document.getElementById(element);\n    if (!container) {\n      throw new TypeError(`The DOM element with the identifier \"${element}\" was not found.`);\n    }\n    element = container;\n  }\n\n  // Check if a DOM element\n  if (!(element instanceof window.HTMLElement)) {\n    throw new TypeError('The first parameter must be an existing DOM element or an identifier.');\n  }\n\n  // The element is not an embed iframe?\n  if (element.nodeName !== 'IFRAME') {\n    // check if already present in the element\n    const iframe = element.querySelector('iframe');\n    if (iframe) {\n      element = iframe;\n    }\n  }\n\n  return element;\n}\n","import { EmbedParameters } from '../types';\n\n/**\n * Build url for the new iframe\n *\n * @param {object} parameters\n */\nexport function buildIframeUrl(parameters: EmbedParameters) {\n  let url = parameters.baseUrl || 'https://flat-embed.com';\n\n  // Score id or blank embed\n  url += '/' + (parameters.score || 'blank');\n\n  // Build qs parameters\n  const urlParameters: Record<string, string | number | boolean> = Object.assign(\n    {\n      jsapi: true,\n    },\n    parameters.embedParams as Record<string, string | number | boolean>,\n  );\n\n  const qs = Object.keys(urlParameters)\n    .map(k => `${encodeURIComponent(k)}=${encodeURIComponent(urlParameters[k])}`)\n    .join('&');\n\n  return url + '?' + qs;\n}\n\n/**\n * Create an iframe inside a specified element\n *\n * @param {HTMLElement} element\n * @param {object} parameters\n */\nexport function createEmbedIframe(\n  element: HTMLElement,\n  parameters: EmbedParameters,\n): HTMLIFrameElement {\n  const url = buildIframeUrl(parameters);\n\n  const iframe = document.createElement('iframe');\n  iframe.setAttribute('src', url);\n  iframe.setAttribute('width', parameters.width || '100%');\n  iframe.setAttribute('height', parameters.height || '100%');\n  iframe.setAttribute('allowfullscreen', 'true');\n  iframe.setAttribute('allow', 'autoplay; midi');\n  iframe.setAttribute('frameborder', '0');\n\n  if (parameters.lazy) {\n    iframe.setAttribute('loading', 'lazy');\n  }\n\n  element.appendChild(iframe);\n\n  return iframe;\n}\n","import Embed from '../embed';\nimport { EmbedMessageReceived } from '../types';\n\n/**\n * Send a message to the embed via postMessage\n *\n * @param embed The instance of the embed where to send the message\n * @param method The name of the method to call\n * @param parameters The parameters to pass to the method\n */\nexport function postMessage(embed: Embed, method: string, parameters?: unknown): void {\n  if (!embed.element.contentWindow || !embed.element.contentWindow.postMessage) {\n    throw new Error('No `contentWindow` or `contentWindow.postMessage` available on the element');\n  }\n\n  const message = {\n    method,\n    parameters,\n  };\n\n  embed.element.contentWindow.postMessage(message, embed.origin);\n}\n\n/**\n * Parse a message received from postMessage\n *\n * @param data The data received from postMessage\n * @return Received message from the embed\n */\nexport function parseMessage(data: string | Record<string, unknown>): EmbedMessageReceived {\n  if (typeof data === 'string') {\n    data = JSON.parse(data);\n  }\n  return data as unknown as EmbedMessageReceived;\n}\n","import type Embed from '../embed';\nimport {\n  EmbedMessageReceived,\n  EmbedMessageReceivedEvent,\n  EmbedMessageReceivedMethod,\n} from '../types';\nimport type { EmbedEventName } from '../types/events';\n\nclass EmbedCallback {\n  embed: Embed;\n  promises: Partial<\n    Record<string, { resolve: (value: unknown) => void; reject: (reason?: unknown) => void }[]>\n  >;\n  eventCallbacks: Partial<Record<EmbedEventName, ((parameters: unknown) => void)[]>>;\n\n  constructor(embed: Embed) {\n    this.embed = embed;\n    this.promises = {};\n    this.eventCallbacks = {};\n    return this;\n  }\n\n  pushCall(\n    // NOTE: We could type this with list of public methods\n    name: string,\n    resolve: (value: unknown) => void,\n    reject: (reason?: unknown) => void,\n  ) {\n    this.promises[name] = this.promises[name] || [];\n    this.promises[name]!.push({ resolve, reject });\n  }\n\n  /**\n   * Register a callback for a specified event\n   *\n   * @param event The name of the event.\n   * @param callback The function to call when receiving an event\n   * @return `true` if it is the first subscriber, `false otherwise`\n   */\n  subscribeEvent(event: EmbedEventName, callback: (parameters: unknown) => void): boolean {\n    this.eventCallbacks[event] = this.eventCallbacks[event] || [];\n    this.eventCallbacks[event]!.push(callback);\n    return this.eventCallbacks[event]!.length === 1;\n  }\n\n  /**\n   * Unregister a callback for a specified event\n   *\n   * @param event The name of the event.\n   * @param callback The function to call when receiving an event\n   * @return `true` if it is the last subscriber, `false otherwise`\n   */\n  unsubscribeEvent(event: EmbedEventName, callback?: (parameters: unknown) => void): boolean {\n    // Was not subscribed\n    if (!this.eventCallbacks[event]) {\n      return false;\n    }\n\n    // If a callback is specified, unsub this one\n    if (callback) {\n      const idx = this.eventCallbacks[event]!.indexOf(callback);\n      if (idx >= 0) {\n        this.eventCallbacks[event]!.splice(idx, 1);\n      }\n    }\n    // Unsub all\n    else {\n      this.eventCallbacks[event] = [];\n    }\n\n    return !callback || this.eventCallbacks[event]!.length === 0;\n  }\n\n  /**\n   * Process a message received from postMessage\n   *\n   * @param {object} data The data received from postMessage\n   */\n  process(data: EmbedMessageReceived) {\n    if ('method' in data && data.method) {\n      this.processMethodResponse(data);\n    } else if ('event' in data && data.event) {\n      this.processEvent(data);\n    }\n  }\n\n  /**\n   * Process a method response\n   *\n   * @param {object} data The data received from postMessage\n   */\n  processMethodResponse(data: EmbedMessageReceivedMethod) {\n    if (!this.promises[data.method]) {\n      return;\n    }\n    const promise = this.promises[data.method]!.shift();\n    if (!promise) {\n      return;\n    }\n    if (data.error) {\n      promise.reject(data.error);\n    } else {\n      promise.resolve(data.response);\n    }\n  }\n\n  /**\n   * Process a receieved event\n   *\n   * @param {object} data The data received from postMessage\n   */\n  processEvent(data: EmbedMessageReceivedEvent) {\n    if (!this.eventCallbacks[data.event] || this.eventCallbacks[data.event]!.length === 0) {\n      return;\n    }\n    this.eventCallbacks[data.event]!.forEach(callback => {\n      callback.call(this.embed, data.parameters);\n    });\n  }\n}\n\nexport default EmbedCallback;\n","import './lib/compatibility';\n\nimport { normalizeElement } from './lib/dom';\nimport { createEmbedIframe } from './lib/embed';\nimport { postMessage, parseMessage } from './lib/communication';\nimport EmbedCallback from './lib/callback';\nimport type {\n  EmbedEventName,\n  EmbedMessageReceived,\n  EmbedMessageReceivedEvent,\n  EmbedMessageReceivedMethod,\n  EmbedParameters,\n  ScoreTrackConfiguration,\n  PartConfiguration,\n  NoteCursorPosition,\n  NoteCursorPositionOptional,\n  MeasureDetails,\n  NoteDetails,\n  MetronomeMode,\n  PlaybackPosition,\n} from './types';\n\nconst embeds = new WeakMap();\nconst embedsReady = new WeakMap();\n\nclass Embed {\n  origin: string = '*';\n  element!: HTMLIFrameElement;\n  embedCallback!: EmbedCallback;\n\n  /**\n   * Create a new Flat Embed\n   *\n   * @param element A reference to a Flat Embed iframe or a container for the new iframe\n   * @param parameters Parameters for the new iframe\n   */\n  constructor(element: HTMLIFrameElement | HTMLElement | string, parameters: EmbedParameters = {}) {\n    element = normalizeElement(element);\n\n    // Keep a single object instance per iframe\n    if (embeds.has(element)) {\n      return embeds.get(element);\n    }\n\n    // Create new element iframe if needed\n    if (element.nodeName !== 'IFRAME') {\n      element = createEmbedIframe(element, parameters);\n    }\n\n    this.element = element as HTMLIFrameElement;\n    this.embedCallback = new EmbedCallback(this);\n\n    const onReady = new Promise<void>(resolve => {\n      // Handle incoming messages from embed\n      const onMessage = (event: MessageEvent) => {\n        if (this.element.contentWindow !== event.source) {\n          return;\n        }\n\n        if (this.origin === '*') {\n          this.origin = event.origin;\n        }\n\n        // Parse inbound message\n        const data: EmbedMessageReceived = parseMessage(event.data);\n\n        // Mark the embed as ready\n        if (\n          (data as EmbedMessageReceivedEvent).event === 'ready' ||\n          (data as EmbedMessageReceivedMethod).method === 'ping'\n        ) {\n          resolve();\n          return;\n        }\n\n        // Process regular messages from the embed\n        this.embedCallback.process(data);\n      };\n\n      window.addEventListener('message', onMessage, false);\n      postMessage(this, 'ping');\n    });\n\n    embeds.set(this.element, this);\n    embedsReady.set(this.element, onReady);\n\n    return this;\n  }\n\n  ready() {\n    return embedsReady.get(this.element);\n  }\n\n  /**\n   * Call a method on the embed\n   *\n   * @param method Name of the method to call\n   * @param parameters Method parameters\n   * @returns Call result from Embed (if any)\n   */\n  call(\n    method: string,\n    parameters: Record<string, unknown> | string | string[] | number | boolean | Uint8Array = {},\n  ) {\n    return new Promise((resolve, reject) => {\n      return this.ready().then(() => {\n        this.embedCallback.pushCall(method, resolve, reject);\n        postMessage(this, method, parameters);\n      });\n    });\n  }\n\n  /**\n   * Subscribe to a specific event\n   *\n   * @param event The name of the event.\n   * @param callback The function to call when receiving an event\n   */\n  on(event: EmbedEventName, callback: () => void) {\n    if (typeof event !== 'string') {\n      throw new TypeError('An event name (string) is required');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError('An callback (function) is required');\n    }\n    if (this.embedCallback.subscribeEvent(event, callback)) {\n      this.call('addEventListener', event).catch(() => {});\n    }\n  }\n\n  /**\n   * Unsubscribe to a specific event\n   *\n   * @param event The name of the event.\n   * @param callback The function to unsubscribe\n   */\n  off(event: EmbedEventName, callback?: () => void) {\n    if (typeof event !== 'string') {\n      throw new TypeError('An event name (string) is required');\n    }\n    if (this.embedCallback.unsubscribeEvent(event, callback)) {\n      this.call('removeEventListener', event).catch(() => {});\n    }\n  }\n\n  /**\n   * Load a score hosted on Flat\n   *\n   * @param score The unique identifier of the score or an object with { score, sharingKey }\n   * @return {Promise}\n   * @reject {ApiError} Unable to load the score\n   */\n  loadFlatScore(score: string | { score: string; sharingKey?: string }): Promise<void> {\n    if (typeof score === 'string') {\n      score = { score };\n    }\n    return this.call('loadFlatScore', score) as Promise<void>;\n  }\n\n  /**\n   * Load a MusicXML score\n   *\n   * @param score The MusicXML file\n   * @return {Promise}\n   * @reject {Error} Unable to load the score\n   */\n  loadMusicXML(score: string | Uint8Array) {\n    return this.call('loadMusicXML', score) as Promise<void>;\n  }\n\n  /**\n   * Load a Flat JSON score\n   *\n   * @param score The JSON of the score\n   * @return {Promise}\n   * @reject {Error} Unable to load the score\n   */\n  loadJSON(score: string | Record<string, unknown>) {\n    return this.call('loadJSON', score) as Promise<void>;\n  }\n\n  /**\n   * Get the score in Flat JSON format\n   *\n   * @return The Flat data format\n   */\n  getJSON() {\n    return this.call('getJSON') as Promise<Record<string, unknown>>;\n  }\n\n  /**\n   * Convert the displayed score in MusicXML\n   *\n   * @param options Conversion options (`compressed`)\n   * @return {Promise}\n   * @fullfill MusicXML File\n   * @reject Conversion error\n   */\n  getMusicXML(options?: { compressed?: boolean }): Promise<string | Uint8Array> {\n    return new Promise((resolve, reject) => {\n      options = options || {};\n      if (typeof options !== 'object') {\n        return reject(new TypeError('Options must be an object'));\n      }\n      this.call('getMusicXML', options)\n        .then(data => {\n          // Plain XML\n          if (typeof data === 'string') {\n            return resolve(data);\n          }\n          // Compressed, re-create Uint8Array\n          return resolve(new Uint8Array(data as [number]));\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Convert the displayed score in PNG\n   *\n   * @return {Promise}\n   * @fullfill PNG File (Uint8Array or string for dataURL)\n   * @reject Conversion error\n   */\n  getPNG(options?: {\n    /** Export result (either a PNG returned as Uint8Array or in dataURL) */\n    result?: 'Uint8Array' | 'dataURL';\n    /** DPI of exported image (min: 50, max: 300, default: 150) */\n    dpi?: number;\n    /** Layout of exported image */\n    layout?: 'track' | 'page';\n  }): Promise<Uint8Array | string> {\n    return new Promise((resolve, reject) => {\n      options = options || {};\n      if (typeof options !== 'object') {\n        return reject(new TypeError('Options must be an object'));\n      }\n      this.call('getPNG', options)\n        .then(data => {\n          if (typeof data === 'string') {\n            return resolve(data);\n          }\n          resolve(new Uint8Array(data as [number]));\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Convert the displayed score in MIDI\n   *\n   * @return {Promise}\n   * @fullfill MIDI File\n   * @reject Conversion error\n   */\n  getMIDI(): Promise<Uint8Array> {\n    return this.call('getMIDI').then(data => new Uint8Array(data as [number]));\n  }\n\n  /**\n   * Get the metadata of the score (for scores hosted on Flat)\n   *\n   * TODO: Type the result from OpenAPI response\n   *\n   * @return {Promise}\n   * @fulfill {object} The Flat data format (result from https://flat.io/developers/api/reference/#operation/getScore)\n   */\n  getFlatScoreMetadata() {\n    return this.call('getFlatScoreMetadata');\n  }\n\n  /**\n   * Get the whole embed config\n   *\n   * TODO: Type all embed options\n   *\n   * @return {Promise}\n   * @fullfill {object} An object containing the config of the embed\n   */\n  getEmbedConfig(): Promise<Record<string, unknown>> {\n    return this.call('getEmbedConfig') as Promise<Record<string, unknown>>;\n  }\n\n  /**\n   * Set a config for the embed mode\n   * This config can be fetched with `getEmbed()` (as `editor` value)\n   * This config will be applied at the next score loading\n   *\n   * TODO: Type all options\n   *\n   * @param {object} editor The editor config\n   * @return {Promise}\n   * @fullfill {object} An object containing the config of the editor\n   */\n  setEditorConfig(editor: Record<string, unknown>): Promise<void> {\n    return this.call('setEditorConfig', editor) as Promise<void>;\n  }\n\n  /**\n   * Toggle fullscreen state\n   *\n   * @param {boolean} active `true` to switch on fullscreen, `false` to switch off\n   * @return {Promise} Once the state changed\n   */\n  fullscreen(active: boolean): Promise<void> {\n    return this.call('fullscreen', active) as Promise<void>;\n  }\n\n  /**\n   * Start the playback\n   */\n  play(): Promise<void> {\n    return this.call('play') as Promise<void>;\n  }\n\n  /**\n   * Pause the playback\n   */\n  pause(): Promise<void> {\n    return this.call('pause') as Promise<void>;\n  }\n\n  /**\n   * Stop the playback\n   */\n  stop(): Promise<void> {\n    return this.call('stop') as Promise<void>;\n  }\n\n  /**\n   * Mute playback\n   */\n  mute(): Promise<void> {\n    return this.call('mute') as Promise<void>;\n  }\n\n  /**\n   * Get the current master volume\n   */\n  getMasterVolume(): Promise<number> {\n    return this.call('getMasterVolume') as Promise<number>;\n  }\n\n  /**\n   * Set the current master volume\n   */\n  setMasterVolume(parameters: { volume: number }): Promise<void> {\n    return this.call('setMasterVolume', parameters) as Promise<void>;\n  }\n\n  /**\n   * Get the volume of a part\n   */\n  getPartVolume(parameters: { partUuid: string }): Promise<number> {\n    return this.call('getPartVolume', parameters) as Promise<number>;\n  }\n\n  /**\n   * Set the volume of a part\n   */\n  setPartVolume(parameters: { partUuid: string; volume: number }): Promise<void> {\n    return this.call('setPartVolume', parameters) as Promise<void>;\n  }\n\n  /**\n   * Mute a part\n   */\n  mutePart(parameters: { partUuid: string }): Promise<void> {\n    return this.call('mutePart', parameters) as Promise<void>;\n  }\n\n  /**\n   * Mute a part\n   */\n  unmutePart(parameters: { partUuid: string }): Promise<void> {\n    return this.call('unmutePart', parameters) as Promise<void>;\n  }\n\n  /**\n   * Enable the solo mode for a part\n   */\n  setPartSoloMode(parameters: { partUuid: string }): Promise<void> {\n    return this.call('setPartSoloMode', parameters) as Promise<void>;\n  }\n\n  /**\n   * Disable the solo mode for a part\n   */\n  unsetPartSoloMode(parameters: { partUuid: string }): Promise<void> {\n    return this.call('unsetPartSoloMode', parameters) as Promise<void>;\n  }\n\n  /**\n   * Get the state of the solo mode of a part\n   */\n  getPartSoloMode(parameters: { partUuid: string }): Promise<boolean> {\n    return this.call('getPartSoloMode', parameters) as Promise<boolean>;\n  }\n\n  /**\n   * Get the volume of a part\n   */\n  getPartReverb(parameters: { partUuid: string }): Promise<number> {\n    return this.call('getPartReverb', parameters) as Promise<number>;\n  }\n\n  /**\n   * Set the volume of a part\n   */\n  setPartReverb(parameters: { partUuid: string; reverberation: number }): Promise<void> {\n    return this.call('setPartReverb', parameters) as Promise<void>;\n  }\n\n  /**\n   * Configure a new audio or video track\n   */\n  setTrack(parameters: ScoreTrackConfiguration): Promise<void> {\n    return this.call('setTrack', parameters as unknown as Record<string, unknown>) as Promise<void>;\n  }\n\n  /**\n   * Enabled a previously configured track\n   */\n  useTrack(parameters: { id: string }): Promise<void> {\n    return this.call('useTrack', parameters) as Promise<void>;\n  }\n\n  /**\n   * Seek the audio track to a specified duration\n   */\n  seekTrackTo(parameters: { time: number }): Promise<void> {\n    return this.call('seekTrackTo', parameters) as Promise<void>;\n  }\n\n  /**\n   * Print the score\n   */\n  print(): Promise<void> {\n    return this.call('print') as Promise<void>;\n  }\n\n  /**\n   * Get the current zoom ratio\n   *\n   * @return {Promise}\n   * @fullfill {number} The current scale ratio (0.5 to 3)\n   */\n  getZoom(): Promise<number> {\n    return this.call('getZoom') as Promise<number>;\n  }\n\n  /**\n   * Set a new zoom ratio (this will disable the zoom auto if set)\n   *\n   * @param {number} zoom The scale ratio (0.5 to 3)\n   * @return {Promise}\n   * @fullfill {number} The scale ratio applied\n   */\n  setZoom(zoom: number): Promise<number> {\n    return this.call('setZoom', zoom) as Promise<number>;\n  }\n\n  /**\n   * Get the auto-zoom\n   *\n   * @return {Promise}\n   * @fullfill {boolean} `true` if enabled, `false` if disabled\n   */\n  getAutoZoom(): Promise<boolean> {\n    return this.call('getAutoZoom') as Promise<boolean>;\n  }\n\n  /**\n   * Enable or disable the auto-zoom\n   *\n   * @param {boolean} state `true` if enabled, `false` if disabled\n   * @return {Promise}\n   * @fullfill {boolean} The auto-zoom mode\n   */\n  setAutoZoom(state: boolean): Promise<boolean> {\n    return this.call('setAutoZoom', state) as Promise<boolean>;\n  }\n\n  /**\n   * Set the focus to the score\n   */\n  focusScore(): Promise<void> {\n    return this.call('focusScore') as Promise<void>;\n  }\n\n  /**\n   * Get cursor position\n   *\n   * @return {Promise}\n   * @fullfill {boolean} Current cursor position\n   */\n  getCursorPosition(): Promise<NoteCursorPosition> {\n    return this.call('getCursorPosition') as unknown as Promise<NoteCursorPosition>;\n  }\n\n  /**\n   * Set cursor position\n   *\n   * @param {object} position New cursor position\n   * @return {Promise}\n   * @fullfill {boolean} Current cursor position\n   */\n  setCursorPosition(position: NoteCursorPositionOptional): Promise<void> {\n    return this.call('setCursorPosition', position as Record<string, unknown>) as Promise<void>;\n  }\n\n  /**\n   * Get all the parts information\n   *\n   * @return {Promise}\n   * @fullfill {array} List of the parts\n   */\n  getParts(): Promise<PartConfiguration[]> {\n    return this.call('getParts') as Promise<PartConfiguration[]>;\n  }\n\n  /**\n   * Get the displayed parts\n   *\n   * @return {Promise}\n   * @fullfill {array} List of the displayed parts\n   */\n  getDisplayedParts(): Promise<PartConfiguration[]> {\n    return this.call('getDisplayedParts') as Promise<PartConfiguration[]>;\n  }\n\n  /**\n   * Choose the parts to display\n   *\n   * @param {array} parts List of the parts to display (UUIDs, indexes/idx, names or abbv)\n   * @return {Promise}\n   */\n  setDisplayedParts(parts: string[]): Promise<void> {\n    return this.call('setDisplayedParts', parts) as Promise<void>;\n  }\n\n  /**\n   * Get the number of measures in the score.\n   *\n   * @return {Promise}\n   * @fullfill {Number} The number of measures in the score\n   */\n  getNbMeasures(): Promise<number> {\n    return this.call('getNbMeasures') as Promise<number>;\n  }\n\n  /**\n   * Get the measures uuids of the score\n   *\n   * @return {Promise}\n   * @fullfill {Array} The list of measures uuids.\n   */\n  getMeasuresUuids(): Promise<string[]> {\n    return this.call('getMeasuresUuids') as Promise<string[]>;\n  }\n\n  /**\n   * Get all the parts information\n   *\n   * @return {Promise}\n   * @fullfill {object} Measure details\n   */\n  getMeasureDetails(): Promise<MeasureDetails> {\n    return this.call('getMeasureDetails') as Promise<MeasureDetails>;\n  }\n\n  /**\n   * Get the number of parts in the score.\n   *\n   * @return {Promise}\n   * @fullfill {Number} The number of parts in the score\n   */\n  getNbParts(): Promise<number> {\n    return this.call('getNbParts') as Promise<number>;\n  }\n\n  /**\n   * Get the parts uuids of the score\n   *\n   * @return {Promise}\n   * @fullfill {Array} The list of parts uuids.\n   */\n  getPartsUuids(): Promise<string[]> {\n    return this.call('getPartsUuids') as Promise<string[]>;\n  }\n\n  /**\n   * Get the voice uuids that are present in a given measure.\n   *\n   * @return {Promise}\n   * @fullfill {Array} The list of voices uuids.\n   */\n  getMeasureVoicesUuids(parameters: { partUuid: string; measureUuid: string }): Promise<string[]> {\n    return this.call('getMeasureVoicesUuids', parameters) as Promise<string[]>;\n  }\n\n  /**\n   * Get the number of notes in a voice for a given measure.\n   *\n   * @return {Promise}\n   * @fullfill {Number} The number of notes in a voice for a given measure.\n   */\n  getMeasureNbNotes(parameters: {\n    partUuid: string;\n    measureUuid: string;\n    voiceUuid: string;\n  }): Promise<number> {\n    return this.call('getMeasureNbNotes', parameters) as Promise<number>;\n  }\n\n  /**\n   * Get information about a specific note.\n   *\n   * @return {Promise}\n   * @fullfill {object} Note details\n   */\n  getNoteData(parameters: {\n    partUuid: string;\n    measureUuid: string;\n    voiceUuid: string;\n    noteIdx: number;\n  }): Promise<NoteDetails> {\n    return this.call('getNoteData', parameters) as Promise<NoteDetails>;\n  }\n\n  /**\n   * Get information about a specific note.\n   *\n   * @return {Promise}\n   * @fullfill {Number} Note index in the voice/measure.\n   */\n  playbackPositionToNoteIdx(parameters: {\n    partUuid: string;\n    voiceUuid: string;\n    playbackPosition: PlaybackPosition;\n  }): Promise<number> {\n    return this.call('playbackPositionToNoteIdx', parameters) as Promise<number>;\n  }\n\n  /**\n   * Get all the parts information\n   *\n   * @return {Promise}\n   * @fullfill {object} Note details\n   */\n  getNoteDetails(): Promise<NoteDetails> {\n    return this.call('getNoteDetails') as Promise<NoteDetails>;\n  }\n\n  /**\n   * Move the cursor to the next left item in the score (grace note, note or rest).\n   *\n   * @param mute false to play the note the cursor is moving to\n   */\n  goLeft(mute: boolean = false): Promise<void> {\n    return this.call('goLeft', { mute }) as Promise<void>;\n  }\n\n  /**\n   * Move the cursor to the next right item in the score (grace note, note or rest).\n   *\n   * @param mute false to play the note the cursor is moving to\n   */\n  goRight(mute: boolean = false): Promise<void> {\n    return this.call('goRight', { mute }) as Promise<void>;\n  }\n\n  /**\n   * Get the current metronome mode\n   *\n   * @returns {Promise}\n   * @fullfill {Number} The metronome mode\n   */\n  getMetronomeMode(): Promise<MetronomeMode> {\n    return this.call('getMetronomeMode') as Promise<MetronomeMode>;\n  }\n\n  /**\n   * Sett the metronome mode.\n   *\n   * Mode is defined as:\n   * ``` javascript\n   * const METRONOME_MODES = {\n   *   COUNT_IN: 0,\n   *   CONTINUOUS: 1,\n   *   DISABLED: 2,\n   * };\n   * ```\n   *\n   * @param {Number} mode the new metronome mode\n   * @return {Promise}\n   */\n  setMetronomeMode(mode: MetronomeMode): Promise<void> {\n    return this.call('setMetronomeMode', { mode }) as Promise<void>;\n  }\n\n  /**\n   * Get the current metronome mode\n   *\n   * @returns {Promise}\n   * @fullfill The Playback speed\n   */\n  getPlaybackSpeed(): Promise<number> {\n    return this.call('getPlaybackSpeed') as Promise<number>;\n  }\n\n  /**\n   * Set the playback speed.\n   *\n   * 1 is the regular value, then it is a value between 0.2 and 2.\n   *\n   * @param {Number} speed the new playback speed\n   */\n  setPlaybackSpeed(speed: number): Promise<void> {\n    return this.call('setPlaybackSpeed', { speed }) as Promise<void>;\n  }\n\n  /**\n   * Scroll to the cursor position in the score.\n   *\n   * The scrolling is done asynchronously, so it is not guaranteed that it will be complete\n   * by the time the callback is called.\n   */\n  scrollToCursor(): Promise<void> {\n    return this.call('scrollToCursor') as Promise<void>;\n  }\n}\n\nexport default Embed;\n"],"names":["normalizeElement","element","container","iframe","buildIframeUrl","parameters","url","urlParameters","qs","k","createEmbedIframe","postMessage","embed","method","message","parseMessage","data","EmbedCallback","__publicField","name","resolve","reject","event","callback","idx","promise","embeds","embedsReady","Embed","onReady","onMessage","score","options","editor","active","zoom","state","position","parts","mute","mode","speed"],"mappings":"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"}