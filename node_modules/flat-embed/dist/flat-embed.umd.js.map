{"version":3,"file":"flat-embed.umd.js","sources":["../src/lib/compatibility.ts","../src/lib/dom.ts","../src/lib/embed.ts","../src/lib/communication.ts","../src/lib/callback.ts","../src/embed.ts"],"sourcesContent":["if (typeof window.postMessage === 'undefined') {\n  throw new Error('The Flat Embed JS API is not supported in this browser');\n}\n","/**\n * Select and normalize the DOM element input\n */\nexport function normalizeElement(\n  element: HTMLIFrameElement | HTMLElement | string,\n): HTMLIFrameElement | HTMLElement {\n  // Find an element by identifier\n  if (typeof element === 'string') {\n    const container = document.getElementById(element);\n    if (!container) {\n      throw new TypeError(`The DOM element with the identifier \"${element}\" was not found.`);\n    }\n    element = container;\n  }\n\n  // Check if a DOM element\n  if (!(element instanceof window.HTMLElement)) {\n    throw new TypeError('The first parameter must be an existing DOM element or an identifier.');\n  }\n\n  // The element is not an embed iframe?\n  if (element.nodeName !== 'IFRAME') {\n    // check if already present in the element\n    const iframe = element.querySelector('iframe');\n    if (iframe) {\n      element = iframe;\n    }\n  }\n\n  return element;\n}\n","import { EmbedParameters } from '../types';\n\n/**\n * Build url for the new iframe\n *\n * @param {object} parameters\n */\nexport function buildIframeUrl(parameters: EmbedParameters) {\n  let url = parameters.baseUrl || 'https://flat-embed.com';\n\n  // Score id or blank embed\n  url += '/' + (parameters.score || 'blank');\n\n  // Build qs parameters\n  const urlParameters: Record<string, string | number | boolean> = Object.assign(\n    {\n      jsapi: true,\n    },\n    parameters.embedParams as Record<string, string | number | boolean>,\n  );\n\n  const qs = Object.keys(urlParameters)\n    .map(k => `${encodeURIComponent(k)}=${encodeURIComponent(urlParameters[k])}`)\n    .join('&');\n\n  return url + '?' + qs;\n}\n\n/**\n * Create an iframe inside a specified element\n *\n * @param {HTMLElement} element\n * @param {object} parameters\n */\nexport function createEmbedIframe(\n  element: HTMLElement,\n  parameters: EmbedParameters,\n): HTMLIFrameElement {\n  const url = buildIframeUrl(parameters);\n\n  const iframe = document.createElement('iframe');\n  iframe.setAttribute('src', url);\n  iframe.setAttribute('width', parameters.width || '100%');\n  iframe.setAttribute('height', parameters.height || '100%');\n  iframe.setAttribute('allowfullscreen', 'true');\n  iframe.setAttribute('allow', 'autoplay; midi');\n  iframe.setAttribute('frameborder', '0');\n\n  if (parameters.lazy) {\n    iframe.setAttribute('loading', 'lazy');\n  }\n\n  element.appendChild(iframe);\n\n  return iframe;\n}\n","import Embed from '../embed';\nimport { EmbedMessageReceived } from '../types';\n\n/**\n * Send a message to the embed via postMessage\n *\n * @param embed The instance of the embed where to send the message\n * @param method The name of the method to call\n * @param parameters The parameters to pass to the method\n */\nexport function postMessage(embed: Embed, method: string, parameters?: unknown): void {\n  if (!embed.element.contentWindow || !embed.element.contentWindow.postMessage) {\n    throw new Error('No `contentWindow` or `contentWindow.postMessage` available on the element');\n  }\n\n  const message = {\n    method,\n    parameters,\n  };\n\n  embed.element.contentWindow.postMessage(message, embed.origin);\n}\n\n/**\n * Parse a message received from postMessage\n *\n * @param data The data received from postMessage\n * @return Received message from the embed\n */\nexport function parseMessage(data: string | Record<string, unknown>): EmbedMessageReceived {\n  if (typeof data === 'string') {\n    data = JSON.parse(data);\n  }\n  return data as unknown as EmbedMessageReceived;\n}\n","import type Embed from '../embed';\nimport {\n  EmbedMessageReceived,\n  EmbedMessageReceivedEvent,\n  EmbedMessageReceivedMethod,\n} from '../types';\nimport type { EmbedEventName } from '../types/events';\n\nclass EmbedCallback {\n  embed: Embed;\n  promises: Partial<\n    Record<string, { resolve: (value: unknown) => void; reject: (reason?: unknown) => void }[]>\n  >;\n  eventCallbacks: Partial<Record<EmbedEventName, ((parameters: unknown) => void)[]>>;\n\n  constructor(embed: Embed) {\n    this.embed = embed;\n    this.promises = {};\n    this.eventCallbacks = {};\n    return this;\n  }\n\n  pushCall(\n    // NOTE: We could type this with list of public methods\n    name: string,\n    resolve: (value: unknown) => void,\n    reject: (reason?: unknown) => void,\n  ) {\n    this.promises[name] = this.promises[name] || [];\n    this.promises[name]!.push({ resolve, reject });\n  }\n\n  /**\n   * Register a callback for a specified event\n   *\n   * @param event The name of the event.\n   * @param callback The function to call when receiving an event\n   * @return `true` if it is the first subscriber, `false otherwise`\n   */\n  subscribeEvent(event: EmbedEventName, callback: (parameters: unknown) => void): boolean {\n    this.eventCallbacks[event] = this.eventCallbacks[event] || [];\n    this.eventCallbacks[event]!.push(callback);\n    return this.eventCallbacks[event]!.length === 1;\n  }\n\n  /**\n   * Unregister a callback for a specified event\n   *\n   * @param event The name of the event.\n   * @param callback The function to call when receiving an event\n   * @return `true` if it is the last subscriber, `false otherwise`\n   */\n  unsubscribeEvent(event: EmbedEventName, callback?: (parameters: unknown) => void): boolean {\n    // Was not subscribed\n    if (!this.eventCallbacks[event]) {\n      return false;\n    }\n\n    // If a callback is specified, unsub this one\n    if (callback) {\n      const idx = this.eventCallbacks[event]!.indexOf(callback);\n      if (idx >= 0) {\n        this.eventCallbacks[event]!.splice(idx, 1);\n      }\n    }\n    // Unsub all\n    else {\n      this.eventCallbacks[event] = [];\n    }\n\n    return !callback || this.eventCallbacks[event]!.length === 0;\n  }\n\n  /**\n   * Process a message received from postMessage\n   *\n   * @param {object} data The data received from postMessage\n   */\n  process(data: EmbedMessageReceived) {\n    if ('method' in data && data.method) {\n      this.processMethodResponse(data);\n    } else if ('event' in data && data.event) {\n      this.processEvent(data);\n    }\n  }\n\n  /**\n   * Process a method response\n   *\n   * @param {object} data The data received from postMessage\n   */\n  processMethodResponse(data: EmbedMessageReceivedMethod) {\n    if (!this.promises[data.method]) {\n      return;\n    }\n    const promise = this.promises[data.method]!.shift();\n    if (!promise) {\n      return;\n    }\n    if (data.error) {\n      promise.reject(data.error);\n    } else {\n      promise.resolve(data.response);\n    }\n  }\n\n  /**\n   * Process a receieved event\n   *\n   * @param {object} data The data received from postMessage\n   */\n  processEvent(data: EmbedMessageReceivedEvent) {\n    if (!this.eventCallbacks[data.event] || this.eventCallbacks[data.event]!.length === 0) {\n      return;\n    }\n    this.eventCallbacks[data.event]!.forEach(callback => {\n      callback.call(this.embed, data.parameters);\n    });\n  }\n}\n\nexport default EmbedCallback;\n","import './lib/compatibility';\n\nimport { normalizeElement } from './lib/dom';\nimport { createEmbedIframe } from './lib/embed';\nimport { postMessage, parseMessage } from './lib/communication';\nimport EmbedCallback from './lib/callback';\nimport type {\n  EmbedEventName,\n  EmbedMessageReceived,\n  EmbedMessageReceivedEvent,\n  EmbedMessageReceivedMethod,\n  EmbedParameters,\n  ScoreTrackConfiguration,\n  PartConfiguration,\n  NoteCursorPosition,\n  NoteCursorPositionOptional,\n  MeasureDetails,\n  NoteDetails,\n  MetronomeMode,\n  PlaybackPosition,\n} from './types';\n\nconst embeds = new WeakMap();\nconst embedsReady = new WeakMap();\n\nclass Embed {\n  origin: string = '*';\n  element!: HTMLIFrameElement;\n  embedCallback!: EmbedCallback;\n\n  /**\n   * Create a new Flat Embed\n   *\n   * @param element A reference to a Flat Embed iframe or a container for the new iframe\n   * @param parameters Parameters for the new iframe\n   */\n  constructor(element: HTMLIFrameElement | HTMLElement | string, parameters: EmbedParameters = {}) {\n    element = normalizeElement(element);\n\n    // Keep a single object instance per iframe\n    if (embeds.has(element)) {\n      return embeds.get(element);\n    }\n\n    // Create new element iframe if needed\n    if (element.nodeName !== 'IFRAME') {\n      element = createEmbedIframe(element, parameters);\n    }\n\n    this.element = element as HTMLIFrameElement;\n    this.embedCallback = new EmbedCallback(this);\n\n    const onReady = new Promise<void>(resolve => {\n      // Handle incoming messages from embed\n      const onMessage = (event: MessageEvent) => {\n        if (this.element.contentWindow !== event.source) {\n          return;\n        }\n\n        if (this.origin === '*') {\n          this.origin = event.origin;\n        }\n\n        // Parse inbound message\n        const data: EmbedMessageReceived = parseMessage(event.data);\n\n        // Mark the embed as ready\n        if (\n          (data as EmbedMessageReceivedEvent).event === 'ready' ||\n          (data as EmbedMessageReceivedMethod).method === 'ping'\n        ) {\n          resolve();\n          return;\n        }\n\n        // Process regular messages from the embed\n        this.embedCallback.process(data);\n      };\n\n      window.addEventListener('message', onMessage, false);\n      postMessage(this, 'ping');\n    });\n\n    embeds.set(this.element, this);\n    embedsReady.set(this.element, onReady);\n\n    return this;\n  }\n\n  ready() {\n    return embedsReady.get(this.element);\n  }\n\n  /**\n   * Call a method on the embed\n   *\n   * @param method Name of the method to call\n   * @param parameters Method parameters\n   * @returns Call result from Embed (if any)\n   */\n  call(\n    method: string,\n    parameters: Record<string, unknown> | string | string[] | number | boolean | Uint8Array = {},\n  ) {\n    return new Promise((resolve, reject) => {\n      return this.ready().then(() => {\n        this.embedCallback.pushCall(method, resolve, reject);\n        postMessage(this, method, parameters);\n      });\n    });\n  }\n\n  /**\n   * Subscribe to a specific event\n   *\n   * @param event The name of the event.\n   * @param callback The function to call when receiving an event\n   */\n  on(event: EmbedEventName, callback: () => void) {\n    if (typeof event !== 'string') {\n      throw new TypeError('An event name (string) is required');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError('An callback (function) is required');\n    }\n    if (this.embedCallback.subscribeEvent(event, callback)) {\n      this.call('addEventListener', event).catch(() => {});\n    }\n  }\n\n  /**\n   * Unsubscribe to a specific event\n   *\n   * @param event The name of the event.\n   * @param callback The function to unsubscribe\n   */\n  off(event: EmbedEventName, callback?: () => void) {\n    if (typeof event !== 'string') {\n      throw new TypeError('An event name (string) is required');\n    }\n    if (this.embedCallback.unsubscribeEvent(event, callback)) {\n      this.call('removeEventListener', event).catch(() => {});\n    }\n  }\n\n  /**\n   * Load a score hosted on Flat\n   *\n   * @param score The unique identifier of the score or an object with { score, sharingKey }\n   * @return {Promise}\n   * @reject {ApiError} Unable to load the score\n   */\n  loadFlatScore(score: string | { score: string; sharingKey?: string }): Promise<void> {\n    if (typeof score === 'string') {\n      score = { score };\n    }\n    return this.call('loadFlatScore', score) as Promise<void>;\n  }\n\n  /**\n   * Load a MusicXML score\n   *\n   * @param score The MusicXML file\n   * @return {Promise}\n   * @reject {Error} Unable to load the score\n   */\n  loadMusicXML(score: string | Uint8Array) {\n    return this.call('loadMusicXML', score) as Promise<void>;\n  }\n\n  /**\n   * Load a Flat JSON score\n   *\n   * @param score The JSON of the score\n   * @return {Promise}\n   * @reject {Error} Unable to load the score\n   */\n  loadJSON(score: string | Record<string, unknown>) {\n    return this.call('loadJSON', score) as Promise<void>;\n  }\n\n  /**\n   * Get the score in Flat JSON format\n   *\n   * @return The Flat data format\n   */\n  getJSON() {\n    return this.call('getJSON') as Promise<Record<string, unknown>>;\n  }\n\n  /**\n   * Convert the displayed score in MusicXML\n   *\n   * @param options Conversion options (`compressed`)\n   * @return {Promise}\n   * @fullfill MusicXML File\n   * @reject Conversion error\n   */\n  getMusicXML(options?: { compressed?: boolean }): Promise<string | Uint8Array> {\n    return new Promise((resolve, reject) => {\n      options = options || {};\n      if (typeof options !== 'object') {\n        return reject(new TypeError('Options must be an object'));\n      }\n      this.call('getMusicXML', options)\n        .then(data => {\n          // Plain XML\n          if (typeof data === 'string') {\n            return resolve(data);\n          }\n          // Compressed, re-create Uint8Array\n          return resolve(new Uint8Array(data as [number]));\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Convert the displayed score in PNG\n   *\n   * @return {Promise}\n   * @fullfill PNG File (Uint8Array or string for dataURL)\n   * @reject Conversion error\n   */\n  getPNG(options?: {\n    /** Export result (either a PNG returned as Uint8Array or in dataURL) */\n    result?: 'Uint8Array' | 'dataURL';\n    /** DPI of exported image (min: 50, max: 300, default: 150) */\n    dpi?: number;\n    /** Layout of exported image */\n    layout?: 'track' | 'page';\n  }): Promise<Uint8Array | string> {\n    return new Promise((resolve, reject) => {\n      options = options || {};\n      if (typeof options !== 'object') {\n        return reject(new TypeError('Options must be an object'));\n      }\n      this.call('getPNG', options)\n        .then(data => {\n          if (typeof data === 'string') {\n            return resolve(data);\n          }\n          resolve(new Uint8Array(data as [number]));\n        })\n        .catch(reject);\n    });\n  }\n\n  /**\n   * Convert the displayed score in MIDI\n   *\n   * @return {Promise}\n   * @fullfill MIDI File\n   * @reject Conversion error\n   */\n  getMIDI(): Promise<Uint8Array> {\n    return this.call('getMIDI').then(data => new Uint8Array(data as [number]));\n  }\n\n  /**\n   * Get the metadata of the score (for scores hosted on Flat)\n   *\n   * TODO: Type the result from OpenAPI response\n   *\n   * @return {Promise}\n   * @fulfill {object} The Flat data format (result from https://flat.io/developers/api/reference/#operation/getScore)\n   */\n  getFlatScoreMetadata() {\n    return this.call('getFlatScoreMetadata');\n  }\n\n  /**\n   * Get the whole embed config\n   *\n   * TODO: Type all embed options\n   *\n   * @return {Promise}\n   * @fullfill {object} An object containing the config of the embed\n   */\n  getEmbedConfig(): Promise<Record<string, unknown>> {\n    return this.call('getEmbedConfig') as Promise<Record<string, unknown>>;\n  }\n\n  /**\n   * Set a config for the embed mode\n   * This config can be fetched with `getEmbed()` (as `editor` value)\n   * This config will be applied at the next score loading\n   *\n   * TODO: Type all options\n   *\n   * @param {object} editor The editor config\n   * @return {Promise}\n   * @fullfill {object} An object containing the config of the editor\n   */\n  setEditorConfig(editor: Record<string, unknown>): Promise<void> {\n    return this.call('setEditorConfig', editor) as Promise<void>;\n  }\n\n  /**\n   * Toggle fullscreen state\n   *\n   * @param {boolean} active `true` to switch on fullscreen, `false` to switch off\n   * @return {Promise} Once the state changed\n   */\n  fullscreen(active: boolean): Promise<void> {\n    return this.call('fullscreen', active) as Promise<void>;\n  }\n\n  /**\n   * Start the playback\n   */\n  play(): Promise<void> {\n    return this.call('play') as Promise<void>;\n  }\n\n  /**\n   * Pause the playback\n   */\n  pause(): Promise<void> {\n    return this.call('pause') as Promise<void>;\n  }\n\n  /**\n   * Stop the playback\n   */\n  stop(): Promise<void> {\n    return this.call('stop') as Promise<void>;\n  }\n\n  /**\n   * Mute playback\n   */\n  mute(): Promise<void> {\n    return this.call('mute') as Promise<void>;\n  }\n\n  /**\n   * Get the current master volume\n   */\n  getMasterVolume(): Promise<number> {\n    return this.call('getMasterVolume') as Promise<number>;\n  }\n\n  /**\n   * Set the current master volume\n   */\n  setMasterVolume(parameters: { volume: number }): Promise<void> {\n    return this.call('setMasterVolume', parameters) as Promise<void>;\n  }\n\n  /**\n   * Get the volume of a part\n   */\n  getPartVolume(parameters: { partUuid: string }): Promise<number> {\n    return this.call('getPartVolume', parameters) as Promise<number>;\n  }\n\n  /**\n   * Set the volume of a part\n   */\n  setPartVolume(parameters: { partUuid: string; volume: number }): Promise<void> {\n    return this.call('setPartVolume', parameters) as Promise<void>;\n  }\n\n  /**\n   * Mute a part\n   */\n  mutePart(parameters: { partUuid: string }): Promise<void> {\n    return this.call('mutePart', parameters) as Promise<void>;\n  }\n\n  /**\n   * Mute a part\n   */\n  unmutePart(parameters: { partUuid: string }): Promise<void> {\n    return this.call('unmutePart', parameters) as Promise<void>;\n  }\n\n  /**\n   * Enable the solo mode for a part\n   */\n  setPartSoloMode(parameters: { partUuid: string }): Promise<void> {\n    return this.call('setPartSoloMode', parameters) as Promise<void>;\n  }\n\n  /**\n   * Disable the solo mode for a part\n   */\n  unsetPartSoloMode(parameters: { partUuid: string }): Promise<void> {\n    return this.call('unsetPartSoloMode', parameters) as Promise<void>;\n  }\n\n  /**\n   * Get the state of the solo mode of a part\n   */\n  getPartSoloMode(parameters: { partUuid: string }): Promise<boolean> {\n    return this.call('getPartSoloMode', parameters) as Promise<boolean>;\n  }\n\n  /**\n   * Get the volume of a part\n   */\n  getPartReverb(parameters: { partUuid: string }): Promise<number> {\n    return this.call('getPartReverb', parameters) as Promise<number>;\n  }\n\n  /**\n   * Set the volume of a part\n   */\n  setPartReverb(parameters: { partUuid: string; reverberation: number }): Promise<void> {\n    return this.call('setPartReverb', parameters) as Promise<void>;\n  }\n\n  /**\n   * Configure a new audio or video track\n   */\n  setTrack(parameters: ScoreTrackConfiguration): Promise<void> {\n    return this.call('setTrack', parameters as unknown as Record<string, unknown>) as Promise<void>;\n  }\n\n  /**\n   * Enabled a previously configured track\n   */\n  useTrack(parameters: { id: string }): Promise<void> {\n    return this.call('useTrack', parameters) as Promise<void>;\n  }\n\n  /**\n   * Seek the audio track to a specified duration\n   */\n  seekTrackTo(parameters: { time: number }): Promise<void> {\n    return this.call('seekTrackTo', parameters) as Promise<void>;\n  }\n\n  /**\n   * Print the score\n   */\n  print(): Promise<void> {\n    return this.call('print') as Promise<void>;\n  }\n\n  /**\n   * Get the current zoom ratio\n   *\n   * @return {Promise}\n   * @fullfill {number} The current scale ratio (0.5 to 3)\n   */\n  getZoom(): Promise<number> {\n    return this.call('getZoom') as Promise<number>;\n  }\n\n  /**\n   * Set a new zoom ratio (this will disable the zoom auto if set)\n   *\n   * @param {number} zoom The scale ratio (0.5 to 3)\n   * @return {Promise}\n   * @fullfill {number} The scale ratio applied\n   */\n  setZoom(zoom: number): Promise<number> {\n    return this.call('setZoom', zoom) as Promise<number>;\n  }\n\n  /**\n   * Get the auto-zoom\n   *\n   * @return {Promise}\n   * @fullfill {boolean} `true` if enabled, `false` if disabled\n   */\n  getAutoZoom(): Promise<boolean> {\n    return this.call('getAutoZoom') as Promise<boolean>;\n  }\n\n  /**\n   * Enable or disable the auto-zoom\n   *\n   * @param {boolean} state `true` if enabled, `false` if disabled\n   * @return {Promise}\n   * @fullfill {boolean} The auto-zoom mode\n   */\n  setAutoZoom(state: boolean): Promise<boolean> {\n    return this.call('setAutoZoom', state) as Promise<boolean>;\n  }\n\n  /**\n   * Set the focus to the score\n   */\n  focusScore(): Promise<void> {\n    return this.call('focusScore') as Promise<void>;\n  }\n\n  /**\n   * Get cursor position\n   *\n   * @return {Promise}\n   * @fullfill {boolean} Current cursor position\n   */\n  getCursorPosition(): Promise<NoteCursorPosition> {\n    return this.call('getCursorPosition') as unknown as Promise<NoteCursorPosition>;\n  }\n\n  /**\n   * Set cursor position\n   *\n   * @param {object} position New cursor position\n   * @return {Promise}\n   * @fullfill {boolean} Current cursor position\n   */\n  setCursorPosition(position: NoteCursorPositionOptional): Promise<void> {\n    return this.call('setCursorPosition', position as Record<string, unknown>) as Promise<void>;\n  }\n\n  /**\n   * Get all the parts information\n   *\n   * @return {Promise}\n   * @fullfill {array} List of the parts\n   */\n  getParts(): Promise<PartConfiguration[]> {\n    return this.call('getParts') as Promise<PartConfiguration[]>;\n  }\n\n  /**\n   * Get the displayed parts\n   *\n   * @return {Promise}\n   * @fullfill {array} List of the displayed parts\n   */\n  getDisplayedParts(): Promise<PartConfiguration[]> {\n    return this.call('getDisplayedParts') as Promise<PartConfiguration[]>;\n  }\n\n  /**\n   * Choose the parts to display\n   *\n   * @param {array} parts List of the parts to display (UUIDs, indexes/idx, names or abbv)\n   * @return {Promise}\n   */\n  setDisplayedParts(parts: string[]): Promise<void> {\n    return this.call('setDisplayedParts', parts) as Promise<void>;\n  }\n\n  /**\n   * Get the number of measures in the score.\n   *\n   * @return {Promise}\n   * @fullfill {Number} The number of measures in the score\n   */\n  getNbMeasures(): Promise<number> {\n    return this.call('getNbMeasures') as Promise<number>;\n  }\n\n  /**\n   * Get the measures uuids of the score\n   *\n   * @return {Promise}\n   * @fullfill {Array} The list of measures uuids.\n   */\n  getMeasuresUuids(): Promise<string[]> {\n    return this.call('getMeasuresUuids') as Promise<string[]>;\n  }\n\n  /**\n   * Get all the parts information\n   *\n   * @return {Promise}\n   * @fullfill {object} Measure details\n   */\n  getMeasureDetails(): Promise<MeasureDetails> {\n    return this.call('getMeasureDetails') as Promise<MeasureDetails>;\n  }\n\n  /**\n   * Get the number of parts in the score.\n   *\n   * @return {Promise}\n   * @fullfill {Number} The number of parts in the score\n   */\n  getNbParts(): Promise<number> {\n    return this.call('getNbParts') as Promise<number>;\n  }\n\n  /**\n   * Get the parts uuids of the score\n   *\n   * @return {Promise}\n   * @fullfill {Array} The list of parts uuids.\n   */\n  getPartsUuids(): Promise<string[]> {\n    return this.call('getPartsUuids') as Promise<string[]>;\n  }\n\n  /**\n   * Get the voice uuids that are present in a given measure.\n   *\n   * @return {Promise}\n   * @fullfill {Array} The list of voices uuids.\n   */\n  getMeasureVoicesUuids(parameters: { partUuid: string; measureUuid: string }): Promise<string[]> {\n    return this.call('getMeasureVoicesUuids', parameters) as Promise<string[]>;\n  }\n\n  /**\n   * Get the number of notes in a voice for a given measure.\n   *\n   * @return {Promise}\n   * @fullfill {Number} The number of notes in a voice for a given measure.\n   */\n  getMeasureNbNotes(parameters: {\n    partUuid: string;\n    measureUuid: string;\n    voiceUuid: string;\n  }): Promise<number> {\n    return this.call('getMeasureNbNotes', parameters) as Promise<number>;\n  }\n\n  /**\n   * Get information about a specific note.\n   *\n   * @return {Promise}\n   * @fullfill {object} Note details\n   */\n  getNoteData(parameters: {\n    partUuid: string;\n    measureUuid: string;\n    voiceUuid: string;\n    noteIdx: number;\n  }): Promise<NoteDetails> {\n    return this.call('getNoteData', parameters) as Promise<NoteDetails>;\n  }\n\n  /**\n   * Get information about a specific note.\n   *\n   * @return {Promise}\n   * @fullfill {Number} Note index in the voice/measure.\n   */\n  playbackPositionToNoteIdx(parameters: {\n    partUuid: string;\n    voiceUuid: string;\n    playbackPosition: PlaybackPosition;\n  }): Promise<number> {\n    return this.call('playbackPositionToNoteIdx', parameters) as Promise<number>;\n  }\n\n  /**\n   * Get all the parts information\n   *\n   * @return {Promise}\n   * @fullfill {object} Note details\n   */\n  getNoteDetails(): Promise<NoteDetails> {\n    return this.call('getNoteDetails') as Promise<NoteDetails>;\n  }\n\n  /**\n   * Move the cursor to the next left item in the score (grace note, note or rest).\n   *\n   * @param mute false to play the note the cursor is moving to\n   */\n  goLeft(mute: boolean = false): Promise<void> {\n    return this.call('goLeft', { mute }) as Promise<void>;\n  }\n\n  /**\n   * Move the cursor to the next right item in the score (grace note, note or rest).\n   *\n   * @param mute false to play the note the cursor is moving to\n   */\n  goRight(mute: boolean = false): Promise<void> {\n    return this.call('goRight', { mute }) as Promise<void>;\n  }\n\n  /**\n   * Get the current metronome mode\n   *\n   * @returns {Promise}\n   * @fullfill {Number} The metronome mode\n   */\n  getMetronomeMode(): Promise<MetronomeMode> {\n    return this.call('getMetronomeMode') as Promise<MetronomeMode>;\n  }\n\n  /**\n   * Sett the metronome mode.\n   *\n   * Mode is defined as:\n   * ``` javascript\n   * const METRONOME_MODES = {\n   *   COUNT_IN: 0,\n   *   CONTINUOUS: 1,\n   *   DISABLED: 2,\n   * };\n   * ```\n   *\n   * @param {Number} mode the new metronome mode\n   * @return {Promise}\n   */\n  setMetronomeMode(mode: MetronomeMode): Promise<void> {\n    return this.call('setMetronomeMode', { mode }) as Promise<void>;\n  }\n\n  /**\n   * Get the current metronome mode\n   *\n   * @returns {Promise}\n   * @fullfill The Playback speed\n   */\n  getPlaybackSpeed(): Promise<number> {\n    return this.call('getPlaybackSpeed') as Promise<number>;\n  }\n\n  /**\n   * Set the playback speed.\n   *\n   * 1 is the regular value, then it is a value between 0.2 and 2.\n   *\n   * @param {Number} speed the new playback speed\n   */\n  setPlaybackSpeed(speed: number): Promise<void> {\n    return this.call('setPlaybackSpeed', { speed }) as Promise<void>;\n  }\n\n  /**\n   * Scroll to the cursor position in the score.\n   *\n   * The scrolling is done asynchronously, so it is not guaranteed that it will be complete\n   * by the time the callback is called.\n   */\n  scrollToCursor(): Promise<void> {\n    return this.call('scrollToCursor') as Promise<void>;\n  }\n}\n\nexport default Embed;\n"],"names":["normalizeElement","element","container","iframe","buildIframeUrl","parameters","url","urlParameters","qs","k","createEmbedIframe","postMessage","embed","method","message","parseMessage","data","EmbedCallback","__publicField","name","resolve","reject","event","callback","idx","promise","embeds","embedsReady","Embed","onReady","onMessage","score","options","editor","active","zoom","state","position","parts","mute","mode","speed"],"mappings":"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"}